# HackerRank : Sherlock and Cost

## 링크
https://www.hackerrank.com/challenges/sherlock-and-cost/problem

## DP (Dynamic Programming)이란?

작은 부분 문제의 정답을 이용해서 큰 문제의 정답을 구성해나가는 기법이야.  
조건은:  
- 부분 문제의 중복(subproblems)
- 최적 부분 구조(optimal substructure)

## 🤔 이 문제에선 어떤 DP 구조가 숨어 있냐면…

우리가 i번째 인덱스를 고려할 때:

A[i] = 1로 했을 때의 최댓값 (lowCost)  
A[i] = B[i]로 했을 때의 최댓값 (highCost)  
이건 결국:

<b>“i-1번째까지의 선택(부분 문제의 최적 결과)에 기반해서 i번째의 최적 결과를 구하는 것”</b>이야.
이게 DP의 핵심 패턴이야.

## 💡 예시로 볼게

예를 들어 B = [1, 2, 3]일 때,

i = 1일 때는 A[1]이 1일 수도 있고 2일 수도 있어  
i = 2일 때 A[2] = 1 or 3을 고려할 때,  
그 이전 선택(A[1])이 뭔지에 따라 현재의 선택이 달라져  
즉, 이전의 결과(부분 문제)를 기반으로 현재 최적값을 계속 누적하는 구조이기 때문에 이건 DP야.

## ✅ 이건 "탑다운 재귀 + 메모이제이션"은 아니고

👉 <b>"보텀업 DP with 상태변수 2개"</b>라고 볼 수 있어.

dp[i][0] = i번째에서 A[i]=1일 때 cost  
dp[i][1] = i번째에서 A[i]=B[i]일 때 cost  
이걸 매번 배열로 저장하는 대신,  
이전 상태만 기억하면 되니까 변수 2개만 쓰는 최적화된 DP 형태가 된 거지.

## 📌 결론

이게 DP인 이유는:

이전 선택(부분 문제)의 최적값을 저장해두고,
그걸 기반으로 다음 문제의 최적값을 계산하기 때문이야.  
반복문으로 상태를 업데이트하며 최적값을 점진적으로 쌓아가고 있음