# Hacker Rank : Snakes and Ladders - The Quickest Way Up

### 링크 

https://www.hackerrank.com/challenges/the-quickest-way-up/problem

---
## 구현 포인트
### "최단거리" => BFS로 풀자!

---
## 방문 처리를 해줘야하는 이유
### => 다시 방문했을 떄는 무조건 주사위 횟수가 더 많다.

BFS는 항상 먼저 도달한 경로가 "최단 경로"이기 때문에,  
같은 칸에 더 적은 주사위 횟수로 다시 도달하는 일은 절대 없어.   

### 🔍 왜 그런 일이 절대 없냐면?
BFS는 다음처럼 계층적으로 퍼져나가:

시작 칸에서 주사위 1번 굴려서 갈 수 있는 모든 칸을 먼저 탐색  
그 다음에 주사위 2번 굴려야 도달할 수 있는 칸들을 탐색  
...
그래서 어떤 칸에 도달한 순간 = 그 칸에 갈 수 있는 가장 빠른 경우  
즉,

BFS는 먼저 큐에 들어간 칸이 먼저 나옴 (선입선출)  
큐에 들어갈 때마다 moves + 1이기 때문에,  
→ 한 칸이 큐에 처음 들어갈 때의 moves 값이 항상 최소  

---

## 🔄 DFS는 다르다!
반대로 DFS는 경로를 막 깊이 파니까

먼저 도달한 경우가 오히려 돌아온 경우일 수도 있고  
나중에 더 짧은 경로를 찾는 일이 생김  
→ 그래서 DFS는 visited 대신 거리 배열을 비교하는 경우도 있어.  


