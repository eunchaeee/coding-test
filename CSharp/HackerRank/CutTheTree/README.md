# Hacker Rank : Cut the Tree

## 링크
https://www.hackerrank.com/challenges/cut-the-tree/problem
## 개선 포인트
1. root는 자를 수 없으므로 마지막에 경우의 수에서 뺀다.
2. data는 건드리지 않는다. 원본유지!!! <= 인덱싱을 맞춰줄 수 있어서 풀기도 편해짐.
3. 트리는 DFS로 풀자.

### 🧠 왜 DFS가 더 흔히 쓰일까?

이유는 다음과 같아:

1. 트리 구조는 DFS에 자연스럽게 맞는다
   •	트리는 순환이 없고 계층 구조가 있으니, 부모 → 자식 방향으로 순회하는 DFS가 직관적이야.
   •	DFS를 돌면서 서브트리의 값을 자연스럽게 계산할 수 있음.

2. 서브트리 합을 계산하는 데 최적
   •	각 노드 기준으로 “이 노드를 루트로 하는 서브트리 합”을 재귀적으로 계산하는 게 핵심인데,
   •	이건 DFS로 부모가 자식 값을 받아오는 구조에 딱 맞아.

3. 시간복잡도 상 유리함
   •	DFS는 한 번만 방문하니까 O(n)으로 끝나고,
   •	BFS로 같은 걸 하려면 큐 관리나 visited 체크가 더 복잡하게 얽혀서 코드가 지저분해져.

4. 이 문제는 누적하면서 계산 → 재귀가 딱임
   •	자식 → 부모로 값을 넘기며 누적하는 구조는 재귀 함수로 훨씬 깔끔하게 표현 가능해.

# 1. 트리(Tree)
사이클이 없는 연결 그래프.
계층 구조(hierrchy)를 표현하기에 적합.

## 기본 구성 요소
- 노드(Node) : 데이터를 담는 단위
- 루트(Root) : 트리의 시작점. 한 개만 존재.
- 간선(Edge) : 노드와 노드를 연결하는 선.
- 부모(Parent) : 어떤 노드를 기준으로 그 위에 있는 노드.
- 자식(Child) : 부모 아래에 있는 노드
- 리프(Leaf) : 자식이 없는 노드
- 서브트리(Subtree) : 어떤 노드를 루트로 가지는 하위 트리

⸻
## 📌 트리의 특징


| 특징                      | 설명                                                                 |
|---------------------------|----------------------------------------------------------------------|
| 사이클 없음               | 노드에서 시작해 자기 자신으로 돌아오는 경로(사이클)가 없음           |
| N개의 노드 → N-1개의 간선 | 항상 이 조건을 만족함 (그래서 사이클이 없음)                        |
| 유일한 경로 존재          | 두 노드 사이에는 항상 하나의 유일한 경로만 존재함                   |
| 계층적 구조 표현 가능     | 부모-자식 관계를 통해 상하 구조, 트리 구조 표현 가능                |
| 루트 존재                 | 최상단에 단 하나의 루트 노드가 존재함                               |
| 연결 그래프               | 모든 노드가 하나로 이어져 있는 상태 (Disconnected 하면 트리 아님)     |
⸻

## 🌲 트리의 종류
- 이진 트리(Binary Tree): 자식이 최대 2개인 트리  
- 완전 이진 트리: 왼쪽부터 차례로 채워진 이진 트리
- 포화 이진 트리: 모든 노드가 0개 또는 2개의 자식을 가지는 트리
- 이진 탐색 트리(BST): 왼쪽 자식 < 부모 < 오른쪽 자식을 만족
- 힙(Heap): 우선순위 큐에 쓰이는 트리 (최소/최대 힙)
- 트라이(Trie): 문자열 검색에 최적화된 트리
- 세그먼트 트리, 펜윅 트리: 구간 쿼리용 트리

⸻

## 🛠️ 트리의 활용 예시
- 파일 시스템 (폴더 구조)
- 웹사이트 메뉴 구조
- AI 게임 트리
- 이진 탐색 트리 → 빠른 검색
- 네트워크 라우팅
- 파싱(컴파일러, 계산식 트리)


# 2. 그래프(Graph)

그래프는 `정점(Vertex)`과 `간선(Edge)`으로 이루어진 자료구조로,  
여러 개의 노드가 선으로 연결된 구조이다.

---

## 🧱 구성 요소

| 용어     | 설명                                               |
|----------|----------------------------------------------------|
| 정점(V)  | 데이터를 담는 점 (Node 또는 Vertex 라고도 불림)   |
| 간선(E)  | 노드와 노드를 연결하는 선                         |
| 가중치   | 간선에 붙은 숫자 값 (예: 거리, 비용 등)            |
| 방향성   | 간선이 한쪽 방향인지 양방향인지 여부               |

---

## 📌 그래프의 종류

### 1. 방향성

- **방향 그래프 (Directed Graph)**: 간선이 방향을 가짐 (`A → B`)
- **무방향 그래프 (Undirected Graph)**: 간선이 방향 없음 (`A — B`)

### 2. 가중치

- **가중치 그래프 (Weighted Graph)**: 간선에 비용/거리 등의 값이 있음
- **비가중치 그래프**: 모든 간선의 비용이 동일하거나 없음

### 3. 순환성

- **사이클 있음**: 순환 그래프
- **사이클 없음**: 비순환 그래프 (ex. `트리`)

### 4. 연결성

- **연결 그래프**: 모든 노드가 하나로 연결되어 있음
- **비연결 그래프**: 일부 노드가 단절되어 있음

---

## 🌲 트리 vs 그래프

| 구분        | 그래프               | 트리                             |
|-------------|----------------------|----------------------------------|
| 사이클      | 있을 수도 있음        | 없음                             |
| 루트        | 없어도 됨             | 반드시 하나 있어야 함           |
| 간선 수     | 제한 없음             | `노드 수 - 1`개                  |
| 경로        | 여러 개 있을 수 있음 | 항상 유일한 경로만 존재         |

---

## 🛠️ 그래프 활용 예시

- 지도에서 길 찾기 (ex. 다익스트라, BFS)
- 소셜 네트워크 관계 분석
- 웹 크롤링
- 컴퓨터 네트워크 구조
- 게임 맵 설계
- 위상 정렬 (컴파일 순서, 작업 순서 결정)